#pragma once

/* https://en.wikibooks.org/wiki/C%2B%2B_Programming/Code/Design_Patterns#Proxy

Proxy

The Proxy Pattern will provide an object a surrogate or placeholder for another object
to control access to it. It is used when you need to represent a complex object with a 
simpler one. If creation of an object is expensive, it can be postponed until the very
need arises and meanwhile a simpler object can serve as a placeholder. This placeholder
object is called the “Proxy” for the complex object. */

#include <iostream>
#include <vector>

void my_func(bool b) { /* Do work */ }

int proxy() {

	std::vector<bool> vec = { 1, 2, 3, 4, 5 };

	bool b1 = vec[3]; 
	my_func(b1); // fine

	auto b2 = vec[3]; // b2's type is proxy std::vector<bool>::reference
	my_func(b2); // undefined behaviour

	// Better approach is to employ explicitly typed initialiser idiom.
	// This makes it obvious we are deliberately creating a variable
	// of a type different from that generated by the initialising expression
	auto b3 = static_cast<bool>(vec[3]);
}